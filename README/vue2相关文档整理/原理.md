# 目录

- [vue 初始化做了哪些事情？](##1)
- [说说你对 vue 中双向数据绑定的理解?](##1)
- [说说 vue 中双向数据绑定的原理是什么？里面的关键点是什么？](##1)
- [MVC，MVP 和 MVVM 的区别？](##1)
- [Vue 的 diff 算法和虚拟 DOM 了解吗？](##1)
- [computed 和 watch 的实现原理？](##1)
- [vue 框架原理？](##1)

## vue 初始化做了哪些事情？

合并组件选项，将组件配置项打平，存放到 vm.$options 选项上，减少原型链的查找
        对组件关系属性进行初始化，比如：$root、$parent、$children、$refs 等
        初始化自定义事件，比如：@myclick="clickHandle" 会被编译为this.$on('myClick', function clickHandle(){}) 和 this.$emit('myClick') 的形式
        初始化插槽（vm.$slots、vm.$scopedSlots）、定义_c方法，即createElement（h函数）、对$attrs 和\$listeners 属性进行响应式处理
执行 beforeCreate 生命周期函数
初始化 inject 选项，根据 inject 选项从祖代组件配置项中找到对应的 provide 选项，从而获取对应 key 中的值，得到 result[id]= val 形式的结果
初始化 state 数据，如：props、data、methods、watch、computed 等
处理 provide 选项，判断 provide 是不是函数，是函数就调用获取返回配置项，否则就直接使用 provide 选项
执行 created 生命周期函数

## 说说你对 vue 中双向数据绑定的理解?

双向数据绑定是通过数据劫持+发布订阅者的模式来实现的。数据劫持就是通过 object.defineProperty 中的 set 和 get 方法劫持数据属性的变化和修改。在数据发生变化的时候发布消息给订阅者，触发对象的监听回调渲染视图。实现数据的变化视图更新，视图变化数据更新。
第一步：实现数据代理需要对 object.defineProperty 进行封装，这里将它封装在 defineRactive 函数中，然后通过 Obsever 函数对其进行递归遍历，这样可以让其嵌套属性中子属性中都添加 getter 和 setter。
通过 compile 模板去解析指令，把每个模版中的变量解析成数据，初始化渲染视图，添加 Watcher 订阅者，把每个指令对应的节点绑定更新函数，数据变化，则更新视图。
Watcher 订阅者是 compile 模板和 Obsever 函数之间的桥梁。
watcher 的作用就是通过 getter 方法去收集依赖，将搜集的依赖放在 Dep 类中，当自身的依赖发生变化的时候调用 Dep 中 update 方法去触发 compile 中的回调。

## 说说 vue 中双向数据绑定的原理是什么？里面的关键点是什么？

vue 实现双向数据绑定的核心特性是允许视图和数据保持同步，这其中的依赖以下几个关键部分：
1、vue 中使用 Object.difineProperty 方法劫持各个属性的 getter 和 setter，当数据发生变化的时候发布消息给订阅者，触发相应的监听回调。
Object.defineProperty(data, 'prop', {  
 get() {  
 // 当读取 prop 时触发  
 },  
 set(newVal) {  
 // 当修改 prop 时触发  
 // 通知视图更新  
 }  
 }); 2.观察者 (Observer)
在 Vue 实例创建时，Vue 会遍历 data 中的所有属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter，这样 Vue 就能够追踪到每一个属性的变化，从而实现数据的变化驱动视图的变化。 3. 编译阶段 (Compile)
Vue 会将模板编译成虚拟 DOM 渲染函数。在编译过程中，会解析模板中的所有指令（如 v-model、v-bind 等），并为这些指令生成相应的数据绑定函数。 4. 依赖收集 (Dep)
每个属性都持有一个 Dep 对象，用于存储所有订阅了该属性的 Watcher 对象。当属性变化时，会通知其对应的 Dep 对象，Dep 对象会广播消息给所有订阅的 Watcher 对象，从而触发视图的更新。 5. Watcher
Watcher 对象用于观察数据的变化。在创建 Watcher 对象时，会传入一个回调函数（通常是更新视图的函数），并把这个回调函数添加到对应属性的 Dep 对象中，以便在数据变化时收到通知。 6. 虚拟 DOM (Virtual DOM)
Vue 使用虚拟 DOM 技术来减少真实 DOM 的操作，从而提高性能。当数据变化时，Vue 会生成一个新的虚拟 DOM 树，并与旧的虚拟 DOM 树进行对比，计算出最小的差异，然后将这些差异应用到真实 DOM 上。

      关键点：

      数据劫持：通过 Object.defineProperty 实现数据变化的监听。
      观察者：用于追踪数据的变化。
      依赖收集：建立数据与视图之间的依赖关系。
      Watcher：观察数据变化并触发视图更新。
      虚拟 DOM：减少真实 DOM 操作，提高性能。
      这种双向数据绑定机制使得 Vue 能够实现高效的响应式数据驱动视图更新。

## MVC，MVP 和 MVVM 的区别？

总结：
MVVM 是一种软件架构设计模式，它抽离了视图、数据和逻辑，并限定了 Model 和 View 只能通过 VM 进行通信，VM 订阅 Model 并在数据更新时候自动同步到视图。
MVC 将应用抽象为数据层（Model）、视图层（View）、逻辑层（controller），降低了项目耦合。但 MVC 并未限制数据流，Model 和 View 之间可以通信。
MVP 则限制了 Model 和 View 的交互都要通过 Presenter ，这样对 Model 和 View 解耦，提升项目维护性和模块复用性。
而 MVVM 是对 MVP 的 P 的改造，用 VM 替换 P ，将很多手动的数据=>视图的同步操作自动化，降低了代码复杂度，提升可维护性。

## Vue 的 diff 算法和虚拟 DOM 了解吗？

虚拟 dom 其实本身是一个 js 对象，在 vue 中通过 render 函数生成。
虚拟 DOM 之所以出现是由于传统的 api 或者 jQuery 去操作 DOM 的时代价是昂贵的，由于真实 DOM 的元素及其庞大，操作真实 DOM 的性能会很低。
虚拟 DOM 出现的优势是它抽象了原本的渲染过程，同时实现了跨平台的能力，不局限浏览器，ios，小程序等等。
当响应式数据发生改变的时候，render 函数会生成一个新的虚拟 DOM，然后去和旧的虚拟 DOM 进行比对，找到需要更改的节点，同时去更新真实的 DOM。
diff 算法的作用就是用于新旧虚拟 DOM 的比较，diff 算法会返回一个 patch 对象，这个对象中存储新旧虚拟 DOM 中改变的节点信息，最后通过纪录的信息去更改真实的 DOM。

## computed 和 watch 的实现原理？

computed 是 data 属性的一个订阅者，它在初始化时候被 data 属性收集依赖，当 computed 依赖的 data 属性改变后，标记该 computed 为 dirty，即数据更改过，当渲染使用到 computed 时候，再计算出 computed 的值从而得到最新的正确的值。

        watch：在组件初始化时候，遍历所有的watch，对每个watch创建订阅者，绑定依赖的data属性，当data属性改变后发布给订阅者，然后会执行相应地回调。

## vue 框架原理？

我们使用 Vue 开发应用，实际上是编写若干 Vue 组件，实现模板、data、生命周期钩子等，然后执行 new Vue()，将根组件挂载到指定的 DOM 节点上面，当我们编写的组件中生命周期钩子里面的或者在模板的元素事件中改变数据时候，视图会响应地更新。这样就实现了应用。
那么 Vue 是如何实现上面的效果的呢？
new Vue()之后，Vue 会从根组件开始，遍历整个组件树，对每个组件进行处理。
对于一个 Vue 组件，Vue 首先会进行模板编译，将模板编译为 render 函数，render 函数返回虚拟 DOM，如果遇到子组件，也对子组件做同样操作，最终形成一个虚拟 DOM 树。
Vue 会把虚拟 DOM 映射到真实 DOM 并渲染到指定节点上，这样就实现了视图的渲染。
Vue 在组件初始化时候还会设置数据为响应式，并将依赖于数据的渲染方法、computed、watch 收集起来。
当数据改变后，Vue 会根据初始化时候收集的依赖，更新视图，这时候我们就看到最新的界面了。
