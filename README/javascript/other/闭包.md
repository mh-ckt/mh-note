# 目录

- [什么是闭包?闭包使用场景？](##1)
- [什么是内存泄露？](##1)
- [垃圾回收机制都有哪些策略？](##1)

## 什么是闭包?闭包使用场景？

1. 官方的解释是：闭包是一个函数对于其周边环境的状态的引用的组合叫做闭包，这里的周边环境叫词法环境。
2. 特点：常见的闭包形式是函数嵌套函数，内部函数可以访问外部函数的局部作用域，外部函数访问不到内部函数的作用域。由于闭包中的变量存储在内存中，所以不会被垃圾回收机制回收。同时也避免了被全局变量的污染。
3. 写一个简单的闭包分析代码。

```js
function fn() {
  let num = 1 // 初始化一个局部变量 num，用于记录调用次数
  return function () {
    num++ // 递增局部变量 num
    console.log(num) // 打印递增后的 num 值
  }
}
let result = fn()
result() // 2
result() // 3
result() // 4
```

场景：闭包的常见应用十分广泛，例如常见的防抖，节流函数、定时器，事件回调、一个函数内部返回一个匿名函数、ajax 请求、promise 等。

## 什么是内存泄露？

1. 解释：内存泄露是指不再用的内存没有被及时释放出来，导致该段内存无法被使用就是内存泄漏。
2. 内存泄漏指我们无法在通过 js 访问某个对象，而垃圾回收机制却认为该对象还在被引用，因此垃圾回收机制不会释放该对象，导致该块内存永远无法释放，积少成多，系统会越来越卡以至于崩溃。
3. 常见的导致内存泄露
   3.1、全局变量导致的内存泄露：
   如果在函数内部声明变量时忘记使用 var、let 或 const 关键字，那么这个变量就会成为全局变量。全局变量的生命周期是整个应用程序的运行期，即使不再需要它，它也不会被垃圾回收机制回收，从而导致内存泄露。

   3.2、闭包导致的内存泄露：
   闭包是 JavaScript 中强大的特性之一，但它也可能导致内存泄露。如果闭包引用了外部函数的变量，并且这个闭包被持续引用，那么即使外部函数执行完毕，它的变量也无法被垃圾回收。特别是当闭包作为回调函数使用时，如果回调函数被频繁创建且长时间存在，就可能造成内存泄露。

   3.3、定时器未及时清除：
   使用 setInterval 或 setTimeout 创建的定时器如果没有被清除（使用 clearInterval 或 clearTimeout），那么即使相关的函数或对象已经不再需要，定时器仍然会存在并占用内存。

   3.4、DOM 的引用没有及时释放：
   如果 JavaScript 对象持续引用了不再需要的 DOM 元素（如通过 document.getElementById 获取的 DOM 对象），即使该 DOM 元素已经从 DOM 树中移除，它也无法被垃圾回收。

   3.5、事件监听器没有移除：
   如果为 DOM 元素添加了事件监听器，但没有在适当的时机移除它们（使用 removeEventListener），那么即使相关的 DOM 元素或 JavaScript 对象不再需要，事件监听器仍然会占用内存。

## 垃圾回收机制都有哪些策略？

1.  标记清除法：垃圾回收机制获取根并标记他们，然后访问并标记所有来自它们的引用，然后在访问这些对象并标记它们的引用…如此递进结束后若发现有没有标记的（不可达的）进行删除，进入执行环境的不能进行删除
2.  引用计数法：当声明一个变量并给该变量赋值一个引用类型的值时候，该值的计数+1，当该值赋值给另一个变量的时候，该计数+1，当该值被其他值取代的时候，该计数-1，当计数变为 0 的时候，说明无法访问该值了，垃圾回收机制清除该对象
3.  缺点： 当两个对象循环引用的时候，引用计数无计可施。如果循环引用多次执行的话，会造成崩溃等问题。所以后来被标记清除法取代。
