## 谈谈你对作用域的理解？

作用域是可访问变量的集合或者说范围（例如全局的范围、函数的范围、语句块的范围），在作用域内，变量可访问，在作用域外变量不可访问。
js 是词法作用域，变量的访问范围仅由声明时候的区域决定。
js 的作用域可以分为 3 类
全局作用域：在全局环境下声明的变量。在任意位置可以访问到。
函数作用域：在函数内部声明的变量，函数内部和函数内部声明的函数中都可以访问到。访问变量时候先在函数内部找，找不到则在外层函数中找，直到全局作用域，形成“作用域链”。 函数作用域有“变量提升”和“函数声明提升”的特性。
块级作用域：在语句块声明的变量，使用 let 和 const 声明的变量才作用于块级作用域，块级作用域没有变量提升。

## 什么是作用域链？如何延长？

作用域链：默认情况下，js 代码处于全局作用域（0 级），当我们声明一个函数的时候，就会开辟一个局部作用域（1 级）。 函数里面也可以声明函数，就会又形成局部作用域（2 级）,以此类推就会形成作用域链。

延长作用域链的方法：
1、try-catch 语句的 catch 块：会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明。
2、with 语句：会将指定的对象添加到作用域链中。

## 变量提升是什么？与函数提升有什么区别？

变量提升：
1、变量的提升只有声明会被提升，初始化不会被提升。
2、变量提升的位置是当前作用域的顶部

      案例一
        console.log(str) // undefined
        var str = 111
      案例一编译后
        var str
        console.log(str) // undefined
        str = 111

      案例二
        if (!foo) {
          var foo = 5
        }
        console.log(foo) // 5
      案例二编译后
        var foo //会将if语句中的声明提升
        if (!foo) {
          foo = 5
        }
        console.log(foo) // 5

      案例三
        let str = 3
        function fn() {
          var str = str || 5
          console.log(str) // 5
        }
        fn()
      案例三编译后
        let str = 3
        function fn() {
          var str
          str = str || 5 //编译后变量str会被提升，所以等号右边的str是undefined
          console.log(str)
        }
        fn()

      函数提升：
        1、函数的声明和初始化都会被提升。
        2、函数的表达式不会被提升。

      案例一
        console.log(fn(3)) // 6
        function fn(num) {
          return num + num
        }
      案例一编译后
        function fn(num) {
          return num + num
        }
        console.log(fn(3)) // 6

      案例二
        console.log(fn(3)) // fn is not a function
        var fn = function (num) {
          return num + num
        }
      案例二编译后
        var fn
        console.log(fn(3)) // fn is not a function
        fn = function (num) {
          return num + num
        }

      案例三
        foo() // 2
        var foo = function () {
          console.log(1)
        }
        foo() // 1
        function foo() {
          console.log(2)
        }
        foo() // 1
      案例三编译后
        var foo
        function foo() {
          console.log(2)
        }
        foo() // 2
        foo = function () {
          console.log(1)
        }
        foo() // 1
        foo() // 1
