# 目录

- [美团：如何将下面的数组转换转换成树结构](##1)
- [美团：当 a=？下面的等式成立](##1)
- [实现一个 add 函数，让它满足一下条件](##1)
- [假设前端有 n 个请求，想每次只请求 3 个，直到请求完成，如何写？](##1)
- [如果有三个 promise，想串行执行如何写？](##1)
- [头条：写一个 mySetInterVal(fn, a, b),每次间隔 a,a+b,a+2b 的时间，然后写一个 myClear，停止上面的 mySetInterVal](##1)
- [递归比较两个对象是否相等？](##1)
- [嵌套数组对象的递归合并？](##1)

## 美团：如何将下面的数组转换转换成树结构

```js
const arr = [
  { id: 1, name: '节点 1', parentId: null },
  { id: 2, name: '节点 1-1', parentId: 1 },
  { id: 3, name: '节点 1-2', parentId: 1 },
  { id: 4, name: '节点 1-1-1', parentId: 2 },
  { id: 5, name: '节点 1-1-2', parentId: 2 },
  { id: 6, name: '节点 1-2-1', parentId: 3 },
  { id: 7, name: '节点 1-2-3', parentId: 3 },
  { id: 8, name: '节点 1-1-1-1', parentId: 4 },
  { id: 9, name: '节点 1-1-1-2', parentId: 4 },
  { id: 10, name: '节点 1-1-2-1', parentId: 5 },
  { id: 11, name: '节点 1-1-2-2', parentId: 5 }
]
```

解答：

```js
// 第一种实现思路
function arrtoTree(arr, parentId = null) {
  return arr.reduce((pred, item) => {
    if (item.parentId === parentId) {
      const children = arrtoTree(arr, item.id)
      if (children.length) {
        item.children = children
      }
      pred.push(item)
    }
    return pred
  }, [])
}
console.log(arrtoTree(arr))

// 第二种实现思路
let result = []
let map = arr.reduce((pred, item) => {
  pred[item.id] = item
  return pred
}, {})
for (let item of arr) {
  if (!item.parentId) {
    result.push(item)
  }
  if (item.parentId in map) {
    let parent = map[item.parentId]
    parent.children = parent.children || []
    parent.children.push(item)
  }
}
console.log(result)
```

## 美团：当 a=？下面的等式成立

```js
if (a == 1 && a == 2 && a == 3) {
  console.log('Hello Word')
}
```

解答：

## 实现一个 add 函数，让它满足一下条件

```js
add(1)(2)(3)() // ====>输出 6
add(1, 2, 3)() // ====>输出 6
add(1, 2)(3)(4, 5, 6)(7, 8)() //====>输出 36
add(1, 2)(3, 4, 5, 6)() //====>输出 21
```

解答：

```js
function add(...args) {
  let sum = 0
  // 返回一个函数，这个函数可以继续接收参数并累加
  function next(...nextArgs) {
    sum += Array.isArray(nextArgs[0]) ? nextArgs.flat().reduce((a, b) => a + b, 0) : nextArgs.reduce((a, b) => a + b, 0)
    // 如果当前没有传入任何参数，返回累加的和
    if (nextArgs.length === 0) {
      return sum
    }
    // 否则返回一个新的函数，用于继续累加
    return next
  }
  // 初始调用时，如果有参数，则先累加这些参数
  if (args.length > 0) {
    sum += Array.isArray(args[0]) ? args.flat().reduce((a, b) => a + b, 0) : args.reduce((a, b) => a + b, 0)
  }
  // 返回用于继续累加的函数
  return next
}
// 测试
console.log(add(1)(2)(3)()) // 输出 6
console.log(add(1, 2, 3)()) // 输出 6
console.log(add(1, 2)(3)(4, 5, 6)(7, 8)()) // 输出 36
console.log(add(1, 2)(3, 4, 5, 6)()) // 输出 21
```

## 假设前端有 n 个请求，想每次只请求 3 个，直到请求完成，如何写？

## 如果有三个 promise，想串行执行如何写？

## 头条：写一个 mySetInterVal(fn, a, b),每次间隔 a,a+b,a+2b 的时间，然后写一个 myClear，停止上面的 mySetInterVal

```js
function mySetInterVal(fn, a, b) {
  this.a = a
  this.b = b
  this.time = 0
  this.handle = -1
  this.start = () => {
    this.handle = setTimeout(() => {
      fn()
      this.time++
      this.start()
      console.log(this.a + this.time * this.b)
    }, this.a + this.time * this.b)
  }

  this.stop = () => {
    clearTimeout(this.handle)
    this.time = 0
  }
}

var a = new mySetInterVal(
  () => {
    console.log('123')
  },
  1000,
  200
)
a.start()
a.stop()
```

## 递归比较两个对象是否相等？

```js
let origin = {
  a: 1,
  c: {
    d: [
      1,
      {
        k: 22
      }
    ],
    f: {
      age: 19
    }
  }
}
let target = {
  a: 1,
  c: {
    d: [
      1,
      {
        k: 22
      }
    ],
    f: {
      age: 19
    }
  }
}

function deepEqual(origin, target) {
  if (typeof target !== 'object' || typeof origin !== 'object') {
    return origin === target
  }

  // 当前是对象的情况
  if (Object.prototype.toString.call(target) === '[object Object]') {
    if (Object.keys(target).length !== Object.keys(origin).length) {
      return false
    }
    for (let key in target) {
      if (!deepEqual(origin[key], target[key])) return false
    }
  }

  // 当前是数组的情况
  if (Object.prototype.toString.call(target) === '[object Array]') {
    if (target.length !== origin.length) {
      return false
    }
    for (let key of Object.keys(target)) {
      if (!deepEqual(origin[key], target[key])) return false
    }
  }
  return true
}

console.log(deepEqual(origin, target))
```

## 嵌套数组对象的递归合并？

问题：将对应的省份合并在一起

```js
let data1 = [
  {
    key: '220000',
    value: '吉林省',
    data: [
      {
        key: '220100',
        value: '长春市',
        data: [
          { key: '220102', value: '南关区' },
          { key: '220103', value: '宽城区' }
        ]
      }
    ]
  },
  {
    key: '330000',
    value: '浙江省',
    data: [{ key: '330200', value: '宁波市' }]
  }
]

let data2 = [
  {
    key: '220000',
    value: '吉林省',
    data: [
      {
        key: '220200',
        value: '吉林市',
        data: [{ key: '220202', value: '昌邑区' }]
      },
      {
        key: '220100',
        value: '长春市',
        data: [
          { key: '220102', value: '南关区' },
          { key: '220104', value: '朝阳区' }
        ]
      },
      { key: '220300', value: '四平市' }
    ]
  },
  {
    key: '330000',
    value: '浙江省',
    data: [{ key: '330100', value: '杭州市' }]
  }
]
```
