# 目录

- [如何判断数组？](##1)
- [h5 中如何实现上拉刷新和下拉加载？](##2)
- [http1.0 和 http2.0 有什么区别？](##3)
- [如何理解闭包，闭包的优缺点?](##4)
- [如何理浏览器中的事件循环?](##5)
- [谈一谈 promise 的使用？](##6)
- [for...in 和 for...of 的区别？](##7)
- [ESModule 和 CommonJS 的差异？import 有多少种写法?](##8)
- [深拷贝和浅拷贝的区别？](##9)
- [防抖和节流的区别？](##10)
- [为什么会产生跨域，如何解决跨域的问题？](##11)

## 如何判断数组？

- 公司

  1. 2024/4/03/10:00 同企人工（自研苏州，线上线下）薪资 11k-22k
  2. 2025/2/24/14:00 数云（外派，线下）薪资 15k-18k
  3. 2025/3/13/16:00 爱奇迹（外派，线上）薪资 10-14k

- 第一次回答：

  1. 通过数组提供的方法，Array.isArray()
  2. 通过数组的原型 constructor 进行判断。
  3. 通过 Object.prototype.toString.call() 上的方法。

- 总结：

  1. 通过数组提供的方法 isArray()进行判断
  2. 通过 instanceof 方法进行判断
  3. 判断数组的构造器 constructor
  4. 能判断简单数据类型也可以用来判断复杂数据类型，使用 Object.prototype.toString.call()。

  ```js
  let arr = [6, 4, 3]
  let isArr1 = Array.isArray(arr)
  let isArr2 = Object.prototype.toString.call(arr)
  let isArr3 = arr instanceof Array
  let isArr4 = arr.constructor.toString().includes('Array')
  console.log('isArr1', isArr1) // true
  console.log('isArr2', isArr2) // [object Array]
  console.log('isArr3', isArr3) // true
  console.log('isArr4', isArr4) // true
  ```

## h5 中如何实现上拉刷新和下拉加载？

- 公司

  1. 2024/5/09/15:00 固德威（苏州外派，线上，薪资：15k-18k）
  2. 2024/12/25/13:30 健朗科技（自研，线上）薪资 14k-20k

- 第一次回答：

- 总结：

## http1.0 和 http2.0 有什么区别？

- 公司

  1. 2024/5/09/15:00 固德威（苏州外派，线上，薪资：15k-18k）
  2. 2024/4/25/15:30 巨匠征程（自研上海，线下，薪资：15k-25k）

- 第一次回答：

- 总结：

## 如何理解闭包，闭包的优缺点？

- 公司

  1. 2024/4/29/15:00 君果信息（自研上海，线下，薪资：9k-12k）
  2. 2024/11/29/17:30 东方希望（外派上海，线上）薪资 11K-20k
  3. 2025/3/3/13:30 医疗（外派，线下）薪资 20k-21k
  4. 2025/3/13/16:00 爱奇迹（外派，线上）薪资 10-14k

- 第一次回答：

  1. 闭包就是函数对于周边环境变量的引用。
  2. 常见的闭包表现形式是函数嵌套函数，内部函数可以访问外部函数的局部变量。外部函数不可以访问内部函数的局部变量。

- 总结：补充

  1. 闭包指的是函数与词法环境的组合。
  2. 闭包常见的表现形式

## 如何理浏览器中的事件循环?

- 公司

  1. 2024/3/27/15:10 上海码纹（自研上海，线上），薪资 15k-25k
  2. 2024/4/25/10:00 缔塔科技（自研上海，线下，薪资：11K-16K）
  3. 2024/5/09/15:00 固德威（苏州外派，线上，薪资：15k-18k）
  4. 2024/5/14/10:30 金赛药业（上海外派，线上，薪资：16k-18k）
  5. 2024/5/16/11:00 美团（上海外派，线上，薪资：15k-18k）
  6. 2024/5/23/14:00 有光科技（外派众安，线上，薪资：14k-16k）
  7. 2025/3/3/13:30 医疗（外派，线下）薪资 20k-21k

- 第一次回答：

- 总结：
  首先 js 是单线程的，这就意味着 js 在执行任务的时候一次只能执行一个，由于 js 中存在异步的情况，比如定时器，事件回调等，这就需要对于异步任务的优先级进行划分，于是就产生了任务队列，在任务队列中产生了宏任务和微任务的概念，常见的宏任务比如 script 标签、定时器、ui 渲染等。而微任务包括 promise 回调（then、catch、finally）、process.nextTick（Node.js 环境）、MutationObserver 等。在一次事件循环的优先级中，首先会先执行同步任务，然后看调用栈中是否为空，如果不为空则执行当前的微任务，最后再执行宏任务。

## 谈一谈 promise 的使用？

- 公司

  1. 2024/3/18/10:30 众安信科（外派上海，线上）薪资 10K-14k
  2. 2024/5/14/14:00 红星美凯龙（上海外派，线上，薪资：15k-18k）
  3. 2024/11/29/17:30 东方希望（外派上海，线上）薪资 11K-20k
  4. 2025/3/3/13:30 医疗（外派，线下）薪资 20k-21k

- 第一次回答：

- 总结：原型上的属性是 then、catch、finally，自身的属性有 resolve、reject、all、race、allSettled。

## for...in 和 for...of 的区别？

- 公司

  1. 2024/5/09/15:00 固德威（苏州外派，线上，薪资：15k-18k）
  2. 2025/2/24/14:00 数云（外派，线下）薪资 15k-18k
  3. 2025/3/13/16:00 爱奇迹（外派，线上）薪资 10-14k

- 第一次回答：

  1. for..in..用于遍历对象，但是只能遍历对象的可枚举属性和原型上的属性。
  2. for..of 不可以遍历对象，对象没有迭代器，for..of 只能遍历有迭代器的数据结构。

- 总结：
  1. for..in..用于遍历对象的可枚举属性，包括对象自身的和继承的可枚举属性。如果只是想要对象自身的可枚举属性可以使用 OBject.keys() 或者 Object.getOwnProptyNames()获取对象自身的 key。
  2. for..in 可以用来遍历数组，但是通常不建议这样做，同时 for..in.. 的性能低于 for..of.., for..in..会遍历对象的原型链所以比 for..of 慢
  3. for..of..不能遍历普通对象，普通对象不存在迭代器，可以用来遍历数组，字符串，Map 和 set 数据结构。

## ESModule 和 CommonJS 的差异？import 有多少种写法?

- 公司

  1. 2024/3/01/10:30 货拉拉面试（外派上海，线上）薪资 10K-11k {##1}
  2. 2024/4/03/10:00 同企人工（自研苏州，线上线下）薪资 11k-22k
  3. 2024/5/09/15:00 固德威（苏州外派，线上，薪资：15k-18k）

- 第一次回答：

  ESModule 和 CommonJS 的差异：

  1. esmodule 和 commonjs 的是两套不同的模块化规范，esmodule 采用的 import 和 export 作为导入和导出，
  2. commonjs 是采用的 module.exports 和 exports 对象进行导出以及 require 函数进行导入。
  3. esmodule 是静态的，所以 import 和 export 必须位于模块的顶层作用域，不能够在条件判断中使用，commonjs 是动态的，所有可以在条件语句中使用。
  4. ESModule：支持异步加载，即可以与 import()一起使用，实现代码分割和懒加载。
  5. CommonJS：模块是同步加载的，这意味着在加载模块时，整个模块的代码会被立即执行。

  import 写法如下：

  1. 导入整个模块：`import a from './index.js'`
  2. 命名导入：`import {a,b} from './index.js'`
  3. 导入并修改命名：`import {a as b} from './index.js'`
  4. 导入所有命名导出：`import * as all from './index.js'` ,或者 `import * as {a,b,c} from './index.js'`
  5. 动态导入：`()=>import('../index.js')` 返回的是一个 promise 对象

- 总结：基本 ok

## 深拷贝和浅拷贝的区别？

- 公司

  1. 2024/4/25/10:00 缔塔科技（自研上海，线下，薪资：11K-16K）
  2. 2024/5/15/10:00 中国李宁（上海外派，线下，薪资：10k-14k）

- 第一次回答：

  1. 浅拷贝是拷贝对象的第一层基础数据类型和应用数据类型的引用地址。
  2. 深拷贝是对于对象中嵌套的每一层属性都进行拷贝。

- 总结：补充
  1. 浅拷贝的内存占用比较低，只是复制引用地址。深拷贝的内存占用比较大复制完整的结构。
  2. 浅拷贝的方法有 Object.assign()、扩展运算符、Array.prototype.slice、Array.prototype.concat
  3. 深拷贝的方式有 JSON.parse()、JSON.stringify()、递归、lodash.clonedeep

## 防抖和节流的区别？

- 公司

  1. 2024/4/25/10:00 缔塔科技（自研上海，线下，薪资：11K-16K）
  2. 2024/5/09/15:00 固德威（苏州外派，线上，薪资：15k-18k）

- 第一次回答：

  1. 防抖是当用户频繁操作的时候只执行最后一次，相电梯里一直进人，等待最后一个人进来再关门。
  2. 节流指的是用户频繁的操作，在每隔一定的时间内只执行一次。
  3. 实现的方式都是通过定时器实现。

- 总结：ok

## 为什么会产生跨域，如何解决跨域的问题？

- 追问问题：a.com 引 b.com/js 文件，向 b.com/api 发 ajax 请求是否会跨域？

  1. 上面的问题会发生跨域，不发生跨域的前提是域名，端口，协议三者相同，上面的 a.com 和 b.com 属于不同的域名

- 公司：

  1. 2024/4/25/10:00 缔塔科技（自研上海，线下，薪资：11K-16K）
  2. 2024/4/26/18:00 全量全速（外派上海，线上，薪资：16k-20k）
  3. 2024/4/29/15:00 君果信息（自研上海，线下，薪资：9k-12k）
  4. 2024/4/30/12:30 科友（自研苏州，线上，薪资：8k-12k）
  5. 2024/5/09/15:00 固德威（苏州外派，线上，薪资：15k-18k）
  6. 2024/5/23/14:00 有光科技（外派众安，线上，薪资：14k-16k）

- 第一次回答：

  1. 产生跨域问题的前提是浏览器的同源策略限制，同源策略指的访问过程中域名、端口、协议三者必须相同。
  2. 常见的解决方案有：第一种：前端配置 jsonP，利用 script 标签不受同源策略的影响，缺点是只能发送 get 请求。 第二种：后段配置 cors，指定可以访问的地址。第三种：前端配置代理服务器。第四种使用跨域浏览器。

- 总结：补充说明

  1. 同源策略是浏览器的核心机制，为了防止网站通过脚本窃取用户信息。
  2. JSONP 的使用：前端定义回调函数，动态的插入 script 标签，服务端将数据包裹在回调函数中。

     ```js
     function handleData(data) {
       console.log(data) // 拿到服务端的数据
     }
     const script = document.createElement('script')
     script.src = 'https://b.com/api?callback=handleData'
     document.head.appendChild(script)

     handleData({ code: 200, data: 'success' }) // 服务端返回的数据
     ```

  3. 前端配置代理服务器，在 vue 中通过 vue.config.js 中配置 proxy，或者在 react 中通过 craco.config.js 文件中配置 proxy，通过 devServer 对象中配置 proxy 对象。

     ```js
       devServer: {
          proxy: {
            // 下面的代理服务器是将前端请求路径 http://localhost:3000/api/user 通过代理去请求 http://localhost:8000/mh/user
            '/api': {
              target: 'http://localhost:8000', // 目标服务器地址
              changeOrigin: true, // 修改请求头中的 origin
              logLevel: 'debug',
              pathRewrite: { '^/api': '/mh' }, // 重写路径（将/api 前缀 换成/mh）
              secure: false // 开发环境用true  生产环境需设为 true
            }
          }
       }
     ```
