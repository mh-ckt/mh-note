# 目录

- [react 中受控组件和非受控组件的区别？](##1)
- [react 的生命周期有哪些？](##2)
- [函数式编程和面向对象编程的区别？](##3)
- [react-router 和 react-router-dom 有哪些区别？](##5)
- [HashRouter 和 BrowserRouter 有什么区别？](##6)
- [用 hooks 模拟 class 里的生命周期?](##8)
- [ref 可以作为其他 Hooks 的依赖项吗?](##9)

## react 中受控组件和非受控组件的区别？{##1}

1. 受控组件指的是组件的值是由 react 的状态控制的，当 react 的状态改变的时候，组件的值也会随之改变，同时对于组件的修改也会映射到 react 的状态中，这通常对于内容的校验是比较有帮助的，受控组件通常是通过 props 传入组件，同时通过 react 的合成事件更新组件的状态。
2. 非受控组件指的是组件值是自己控制的，在非受控组件中通常需要使用 ref 获取组件的 dom 来获取它的值。react 官方推荐使用的也是受控组件的形式，而日常的开发中大多也都是受控组件。

## react 的生命周期有哪些？{##2}

1. constructor(props)：构造函数，通常用于初始化状态（state）和绑定事件处理程序。
2. static getDerivedStateFromProps(nextProps, prevState)：这是一个静态方法，用于根据新的 props 和旧的 state 计算并返回新的 state。
3. render()：类组件中唯一必须实现的方法，用于渲染组件的 UI。
4. componentDidMount()：在组件挂载到 DOM 后立即调用。
5. static getDerivedStateFromProps(nextProps, prevState)：与挂载阶段相同，这个方法在组件更新时也会被调用。
6. shouldComponentUpdate(nextProps, nextState)：在组件接收到新的属性或状态时被调用。
7. getSnapshotBeforeUpdate(prevProps, prevState)：在最近的渲染输出提交给 DOM 之前调用。
8. componentDidUpdate(prevProps, prevState, snapshot)：在组件更新后立即被调用
9. componentWillUnmount()：在组件卸载前立即调用。

## 函数式编程和面向对象编程的区别？{##3}

1. js 中的对象是对于具象世界中事物的一种抽象表达，当我们需要实现某个功能的时候可以把他抽象成一个“对象”，然后一遍一遍的去调用这个对象去完成你想要的功能，所以在面向对象的编程中可以看到数据和逻辑是混在一起的，数据也就是属性，逻辑也就是方法，这也是面向对象的其中一个特点，也就是封装，封装的好处就是只有在实例中才可以访问属性和方法，提高了程序的安全性。当然面向对象还有其他的特点，比如“继承”和“多态”。继承就是子类可以拥有父类的属性和方法，避免了数据的重复定义。多态意味着子类可以拥有新的方法去覆盖父类的共享行为。
2. 与之相对的是函数式编程，函数式编程又叫面向过程，函数式编程的本身是通过一个个函数去分解一个复杂的功能，然后又通过各种组合嵌套实现最终的功能。函数式编程的本质就是一个拼接积木的过程，把一个大的功能通过一个一个个函数拆解最后又拼接在一起。

## react-router 和 react-router-dom 有哪些区别？{##5}

1. React Router DOM 是基于 React Router 的一个专门针对浏览器环境的库。
2. 它扩展了 React Router 提供的功能，专门为 Web 应用提供了一些额外的组件和功能。

## HashRouter 和 BrowserRouter 有什么区别？{##6}

1. BrowserRouter：使用 HTML5 的 history API 进行路由管理，适合 Web 应用。
2. HashRouter：利用 URL 的 hash 部分来进行路由，适合一些静态文件托管的场景。

## 用 hooks 模拟 class 里的生命周期? {##8}

1、当 useEffect 中的依赖项是一个空数组的时候，可以模拟 componentDidMount（组件加载完成）。
2、如果想要模拟 componentWillUnmount（组件卸载之前），可以在 useEffect 的清理函数中实现。
3、如果要模拟 componentDidUpdata（组件更新时），可以在 useEffect 的依赖项中传入对应的 state。
4、如果要模拟 componentWillReceiveProps（当父组件传递新的 props 的时候调用），可以在 useEffect 中传入对应的 props。

## ref 可以作为其他 Hooks 的依赖项吗? {##9}

可以的，ref 的作用是用于访问 DOM 节点或者组件实例，比如当一个 input 框发生改变的时候需要执行某些操作，那么可以在 useEffect 中传入相应的 ref，这样当 ref 的 DOM 发生变化的时候就可以执行对应的 useEffct 中的函数，值得注意的是，通常我们在 useEffct 中传入的 state 和 props，如果使用 ref 作为依赖项，由于 ref 并不会造成组件的重新渲染，通常这样做可能会造成不必要的性能开销。
