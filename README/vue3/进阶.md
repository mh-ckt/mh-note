# 目录

- [vue3.0 相对于 vue2.0 有哪些变化？](##1)
- [vue3 的编译流程？](##1)
- [vue3 内的宏是什么？和语法糖的区别？](##1)
- [vue3 为什么比 vue2 快？](##1)
- [](##1)
- [](##1)
- [](##1)
- [](##1)
- [](##1)
- [](##1)
- [](##1)
- [](##1)
- [](##1)
- [](##1)
- [](##1)
- [](##1)
- [](##1)
- [](##1)
- [](##1)

## vue3.0 相对于 vue2.0 有哪些变化？

源码上的优化

1. 使用 TS 重构
2. 删除一些冷门功能:filter、inline-template
3. 源码结构使用 Monorepo 来进行管理
4. vue3 使用 Proxy 的方式对数据进行劫持，相比 vue2 的 Object.defineProPerty 更加全面。

性能上优化

1. dliff 优化 ,双端 diff,快速 diff(最长递增子序列)
2. 响应式优化
3. 模板编译

语法上的优化

1. 相比 vue2，vue3 采用的 Composition API ，可以更好的将复用代码的逻辑，同时解决了 Vue2 Mixin 的存在的命名冲突隐患，依赖关系不明确，不同组件间配置化使用不够灵活的问题。

## vue3 的编译流程？

vue3 的编译分两部分：编译期和运行期。编译期间，先通过 vue-loader 把单文件组件编译成符合原生 JavaScript 语法的模块；运行期间，会通过内置的模板引擎对模板进行编译，生成 render()函数，且按照先父组件后子组件的顺序对模板进行编译。

## vue3 内的宏是什么？和语法糖的区别？

按照 vue3 官方的说法，defineProps() 、defineEmits()、defineExpose()都是宏，它们使用形式上和函数调用差不多，区别是，第一，这些宏不需要通过模块导入；第二，这些宏会在编译期被编译成符合 JavaScript 原生语法的代码。语法糖也会被编译成符合 JavaScript 原生语法的代码，vue3 官方对这两者进行区分是因为，语法糖创建的是不曾有过的语法，而宏指的是给现有语法新的含义。

## vue3 为什么比 vue2 快？

响应式系统优化：Vue3 引入了新的响应式系统，这个系统的设计让 Vue3 的渲染函数可以在编译时生成更少的代码，这也就意味着在运行时需要更少的代码来处理虚拟 DOM。这个新系统的一个重要改进就是提供了一种基于 Proxy 实现的响应式机制，这种机制为开发人员提供更加高效的 API，也减少了一些运行时代码。
编译优化：Vue3 的编译器对代码进行了优化，包括减少了部分注释、空白符和其他非必要字符的编译，同时也对编译后的代码进行了懒加载优化。
更快的虚拟 DOM：Vue3 对虚拟 DOM 进行了优化，使用了跟 React 类似的 Fiber 算法，这样可以更加高效地更新 DOM 节点，提高性能。
Composition API：Vue3 引入了 Composition API，这种 API 通过提供逻辑组合和重用的方法来提升代码的可读性和重用性。这种 API 不仅可以让 Vue3 应用更好地组织和维护业务逻辑，还可以让开发人员更加轻松地实现优化。
