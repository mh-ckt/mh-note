# 目录

- [`<script setup/>`的实现原理？](##1)
- [什么是虚拟 DOM？diff 算法？vue2 和 vue3 核心 diff 算法区别？](##1)
- [nextTick()的实现原理？](##1)
- [vue2 和 vue3 响应式原理?](##1)
- [provide()和 inject()实现原理？](##1)
- [emit()的实现原理？](##1)
- [v-model 的实现原理？](##1)
- [](##1)
- [](##1)
- [](##1)
- [](##1)
- [](##1)
- [](##1)
- [](##1)
- [](##1)
- [](##1)
- [](##1)
- [](##1)

## `<script setup/>`的实现原理？

`<script setup/>`本质是 setup()函数的语法糖，vue-loader 在编译期间会把`<script setup/>`内的代码编译成 setup()函数，把 defineExpose()内指定的变量编译为 setup()函数的返回值。

## 什么是虚拟 DOM？diff 算法？ vue2 和 vue3 核心 diff 算法区别？

虚拟 dom 是用 JavaScript 语言描述的一个树形结构，用于缓存发生变化的响应式数据，当到达下次刷新周期的时候，一次性把所有发生变化的数据同步到实际 dom 上。diff 算法是同步 vdom 和 dom 数据的算法，采用就地复用的策略实现高效同步。

Vue 2.x 使用的是双向指针遍历的算法，也就是通过逐层比对新旧虚拟 DOM 树节点的方式来计算出更新需要做的最小操作集合。但这种算法的缺点是，由于遍历是从左到右、从上到下进行的，当发生节点删除或移动时，会导致其它节点位置的计算出现错误，因此会造成大量无效的重新渲染。

Vue 3.x 使用了经过优化的单向遍历算法，也就是只扫描新虚拟 DOM 树上的节点，判断是否需要更新，跳过不需要更新的节点，进一步减少了不必要的操作。此外，在虚拟 DOM 创建后，Vue 3 会缓存虚拟 DOM 节点的描述信息，以便于复用，这也会带来性能上的优势。同时，Vue 3 还引入了静态提升技术，在编译时将一些静态的节点及其子节点预先处理成 HTML 字符串，大大提升了渲染性能。
因此，总体来说，Vue 3 相对于 Vue 2 拥有更高效、更智能的 diff 算法，能够更好地避免不必要的操作，并提高了渲染性能。

## nextTick()的实现原理？

nextTick()作用是，让回调函数在下一次刷新 DOM 的时候，具体来说在 onUpdated 后执行。vue3 内的 nextTick()是通过 Promise 实现，当微任务 flushJob 把 Job 队列中的所有函数都执行完了后，nextTick()回调会被推入微任务队列，然后开始执行。

## vue2 和 vue3 响应式原理?

Vue2 的响应式原理：
Vue2 通过 Object.defineProperty 对 data 中的属性进行劫持，当属性值发生变化时，会触发对应的更新函数，从而更新视图。
Vue2 通过 Watcher 来实现数据与视图的双向绑定，当数据发生变化时，Watcher 会通知对应的视图进行更新。
Vue2 的响应式原理存在一些缺陷，例如无法监听数组的变化，需要通过特殊的方法来实现.

Vue3 的响应式原理：
Vue3 使用 Proxy 代替了 Object.defineProperty，Proxy 可以监听到对象的所有属性，包括新增和删除操作。
Vue3 使用了 WeakMap 来存储依赖关系，避免了 Vue2 中 Watcher 的内存泄漏问题。
Vue3 支持了多个根节点的组件，可以更方便地进行组件的复用和组合。

## provide()和 inject()实现原理？

在祖先组件里通过 provide()提供的数据，可以在任意子孙组件里通过 inject()获取。它是通过原型链实现的。

## emit()的实现原理？

emit()是通过发布订阅模式实现的，子组件发送一个事件，父组件收到该事件会立即执行相应的函数。

## v-model 的实现原理？

v-model 实现了数据的双向绑定，它是通过响应式数据+监听输入框事件实现的。
