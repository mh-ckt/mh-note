## vue3.0 相对于 vue2.0 有哪些变化？

源码上的优化

1. 使用 TS 重构
2. 删除一些冷门功能:filter、inline-template
3. 源码结构使用 Monorepo 来进行管理
4. vue3 使用 Proxy 的方式对数据进行劫持，相比 vue2 的 Object.defineProPerty 更加全面。

性能上优化

1. dliff 优化 ,双端 diff,快速 diff(最长递增子序列)
2. 响应式优化
3. 模板编译

语法上的优化

1. 相比 vue2，vue3 采用的 Composition API ，可以更好的将复用代码的逻辑，同时解决了 Vue2 Mixin 的存在的命名冲突隐患，依赖关系不明确，不同组件间配置化使用不够灵活的问题。

## vue3 的编译流程？

vue3 的编译分两部分：编译期和运行期。编译期间，先通过 vue-loader 把单文件组件编译成符合原生 JavaScript 语法的模块；运行期间，会通过内置的模板引擎对模板进行编译，生成 render()函数，且按照先父组件后子组件的顺序对模板进行编译。

## vue3 内的宏是什么？和语法糖的区别？

按照 vue3 官方的说法，defineProps() 、defineEmits()、defineExpose()都是宏，它们使用形式上和函数调用差不多，区别是，第一，这些宏不需要通过模块导入；第二，这些宏会在编译期被编译成符合 JavaScript 原生语法的代码。语法糖也会被编译成符合 JavaScript 原生语法的代码，vue3 官方对这两者进行区分是因为，语法糖创建的是不曾有过的语法，而宏指的是给现有语法新的含义。

## vue3 为什么比 vue2 快？

响应式系统优化：Vue3 引入了新的响应式系统，这个系统的设计让 Vue3 的渲染函数可以在编译时生成更少的代码，这也就意味着在运行时需要更少的代码来处理虚拟 DOM。这个新系统的一个重要改进就是提供了一种基于 Proxy 实现的响应式机制，这种机制为开发人员提供更加高效的 API，也减少了一些运行时代码。
编译优化：Vue3 的编译器对代码进行了优化，包括减少了部分注释、空白符和其他非必要字符的编译，同时也对编译后的代码进行了懒加载优化。
更快的虚拟 DOM：Vue3 对虚拟 DOM 进行了优化，使用了跟 React 类似的 Fiber 算法，这样可以更加高效地更新 DOM 节点，提高性能。
Composition API：Vue3 引入了 Composition API，这种 API 通过提供逻辑组合和重用的方法来提升代码的可读性和重用性。这种 API 不仅可以让 Vue3 应用更好地组织和维护业务逻辑，还可以让开发人员更加轻松地实现优化。

## `<script setup/>`的实现原理？

`<script setup/>`本质是 setup()函数的语法糖，vue-loader 在编译期间会把`<script setup/>`内的代码编译成 setup()函数，把 defineExpose()内指定的变量编译为 setup()函数的返回值。

## 什么是虚拟 DOM？diff 算法？ vue2 和 vue3 核心 diff 算法区别？

虚拟 dom 是用 JavaScript 语言描述的一个树形结构，用于缓存发生变化的响应式数据，当到达下次刷新周期的时候，一次性把所有发生变化的数据同步到实际 dom 上。diff 算法是同步 vdom 和 dom 数据的算法，采用就地复用的策略实现高效同步。

Vue 2.x 使用的是双向指针遍历的算法，也就是通过逐层比对新旧虚拟 DOM 树节点的方式来计算出更新需要做的最小操作集合。但这种算法的缺点是，由于遍历是从左到右、从上到下进行的，当发生节点删除或移动时，会导致其它节点位置的计算出现错误，因此会造成大量无效的重新渲染。

Vue 3.x 使用了经过优化的单向遍历算法，也就是只扫描新虚拟 DOM 树上的节点，判断是否需要更新，跳过不需要更新的节点，进一步减少了不必要的操作。此外，在虚拟 DOM 创建后，Vue 3 会缓存虚拟 DOM 节点的描述信息，以便于复用，这也会带来性能上的优势。同时，Vue 3 还引入了静态提升技术，在编译时将一些静态的节点及其子节点预先处理成 HTML 字符串，大大提升了渲染性能。
因此，总体来说，Vue 3 相对于 Vue 2 拥有更高效、更智能的 diff 算法，能够更好地避免不必要的操作，并提高了渲染性能。

## nextTick()的实现原理？

nextTick()作用是，让回调函数在下一次刷新 DOM 的时候，具体来说在 onUpdated 后执行。vue3 内的 nextTick()是通过 Promise 实现，当微任务 flushJob 把 Job 队列中的所有函数都执行完了后，nextTick()回调会被推入微任务队列，然后开始执行。

## vue2 和 vue3 响应式原理?

Vue2 的响应式原理：
Vue2 通过 Object.defineProperty 对 data 中的属性进行劫持，当属性值发生变化时，会触发对应的更新函数，从而更新视图。
Vue2 通过 Watcher 来实现数据与视图的双向绑定，当数据发生变化时，Watcher 会通知对应的视图进行更新。
Vue2 的响应式原理存在一些缺陷，例如无法监听数组的变化，需要通过特殊的方法来实现.

Vue3 的响应式原理：
Vue3 使用 Proxy 代替了 Object.defineProperty，Proxy 可以监听到对象的所有属性，包括新增和删除操作。
Vue3 使用了 WeakMap 来存储依赖关系，避免了 Vue2 中 Watcher 的内存泄漏问题。
Vue3 支持了多个根节点的组件，可以更方便地进行组件的复用和组合。

## provide()和 inject()实现原理？

在祖先组件里通过 provide()提供的数据，可以在任意子孙组件里通过 inject()获取。它是通过原型链实现的。

## emit()的实现原理？

emit()是通过发布订阅模式实现的，子组件发送一个事件，父组件收到该事件会立即执行相应的函数。

## v-model 的实现原理？

v-model 实现了数据的双向绑定，它是通过响应式数据+监听输入框事件实现的。
