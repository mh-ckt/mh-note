# 目录

- [react 为什么推出了 hooks 去替换 class 组件？](##1)
- [react 中常见的 hooks 有哪些？有什么区别？](##3)
- [封装过哪些高阶组件？如何封装的？](##4)
- [封装过什么组件？比较难的组件是如何封装的?](##5)
- [react 中 fiber 架构解决了什么事情？](##6)
- [react 如何提升性能？](##7)
- [useCallback 和 useMemo 的用法及使用场景？](##7)
- [react 中组件传值的方式有哪些？](##8)

## react 为什么推出了 hooks 去替换 class 组件？

- 公司

  1. 2024/5/09/15:00 固德威（苏州外派，线上，薪资：15k-18k）
  2. 2025/2/24/14:00 数云（外派，线下）薪资 15k-18k

- 第一次回答：

- 总结：

## react 中常见的 hooks 有哪些？有什么区别？

- 公司

  1. 2024/3/27/15:10 上海码纹（自研上海，线上），薪资 15k-25k
  2. 2024/4/29/10:00 括恒技术（自研南京，线上，薪资：15k-18k）
  3. 2025/3/3/13:30 医疗（外派，线下）薪资 20k-21k

- 第一次回答：常见的 hook 有 useState、useEffect、useLayoutEffect、useCallback、useMemo、useContent、useRef 等。

- 总结：
  1. useState：用于管理组件的状态
  2. useReducer：用于处理复杂的状态逻辑
  3. useEffect：用于处理副作用（比如数据请求，订阅），异步执行，不会阻塞浏览器的渲染。
  4. useLayoutEffect：与 useEfect 类似，用于 DOM 更新后同步执行，会阻塞浏览器的渲染。
  5. useRef：用于存储一个不需要渲染的可变值（这个使用 useRef 存储的变量会在每一次渲染的时候保存下来，而使用常规的变量会在渲染的时候重置），同时也可以用于获取 DOM，比如输入框聚焦等。
  6. useCallback：用于缓存一个函数，避免不必要的渲染。
  7. useMemo：用于缓存一个函数的引用，一个计算结果，避免昂贵的计算。
  8. useContent：用于跨组件的数据传递，避免 props 透传的问题。

## 封装过哪些高阶组件？如何封装的？

- 公司

  1. 2024/3/27/15:10 上海码纹（自研上海，线上），薪资 15k-25k
  2. 2025/3/3/13:30 医疗（外派，线下）薪资 20k-21k

- 第一次回答： 高阶组件是一个函数，其接收一个组件作为参数，并返回一个新的组件。这个新的组件会使用你传给它的组件作为子组件。高阶组件的主要目的是重用组件逻辑、增强组件功能以及在不改变原始组件代码的情况下添加额外的功能。

- 总结：
  常见的高阶组件有在列表组件中使用 loading 组件，将 loading 功能封装成一个高阶组件

## 封装过什么组件？比较难的组件是如何封装的？

- 公司

  1. 2024/4/03/10:00 同企人工（自研苏州，线上线下）薪资 11k-22k
  2. 2024/5/23/14:00 有光科技（外派众安，线上，薪资：14k-16k）
  3. 2025/3/3/16:00 图安云（外派，线下）薪资 12k-14k

- 第一次回答：

- 总结：

## react 中 fiber 架构解决了什么事情？

- 公司

  1. 2024/4/26/18:00 全量全速（外派上海，线上，薪资：16k-20k）
  2. 2025/3/3/16:00 图安云（外派，线下）薪资 12k-14k
  3. 2024/5/15/10:00 中国李宁（上海外派，线下，薪资：10k-14k）

- 第一次回答：

  1. react 在 16 版本中引入了 fiber 的架构，在之前的版本中 react 采用的是调和的模式，对于组件的更新是自上而下的遍历虚拟 DOM 树，然后找到对应的真实 DOM 进行更新。
  2. 在一个 60Hz 的屏幕中，浏览器渲染一帧大概是 16.67 毫秒，这一帧主线程可以做很多的事情，比如 js 的执行，动画的渲染，页面的交互等，在 16 版本之前，当有大量的渲染或者频繁的交互，会出现页面卡顿的现象，这是由于 react 的更新是自上而下的递归执行，且不可以中断。在后面改用 fiber 的模式，可以对 react 中的任务进行分块，比如在一帧中浏览器优先进行页面渲染，用户交互，在执行完成后可能会有剩余的时间，比如 16.67ms 执行完渲染还是剩下 4m，这个时候 react 可以用于执行分块的任务，这些分块的任务是可以中断的，当一个任务单位没有执行完成后，可以在下一帧的空闲时间继续执行。

- 总结：

  1. fiber 是 react16 中提出的一种架构模式，在 fiber 出现之前 react 采用递归的方式创建虚拟 DOM，同时递归是不可以中断的，如果组件的层级很深，递归会占用的线程会很长，这个时候就会阻塞渲染主线程，导致页面卡顿。
  2. fiber 架构的核心是重构 react 的渲染机制，fiber 将渲染的过程拆解成可中断的小任务，如果浏览器是 60hz 的，那么一帧的时间是 16.67ms，在每一帧渲染主线程有大量的任务需要执行，同时也可能存在空闲的时间，fiber 就是利用浏览器的空闲时间执行分段任务，同时当任务的执行时间超出了浏览器的空闲时间，那么当前的任务是可以中断的，再次将渲染主线程交给浏览器执行更重要的任务，响应用于的交互，动画等。在下一次的空闲时间再执行上一次没有执行完的任务，这样可以避免主线程长时间被占用页面卡顿的问题。
  3. fiber 在任务分段的过程中，进行了任务分级，比如用户的交互>动画>数据加载，通过调度器进行动态的调度任务，确保重要的任务可以及时得到相应。

## react 如何提升性能？

- 公司

  1. 2024/11/29/17:30 东方希望（外派上海，线上）薪资 11K-20k
  2. 2025/3/3/16:00 图安云（外派，线下）薪资 12k-14k

- 第一次回答：

  1. 对于函数式组件可以使用 react.memo()方法包裹组件，减少组件的不必要渲染。
  2. 使用 useCallback 和 useMemo 方法进行性能优化。
  3. 在 react18 版本中可以使用 useTransition 方法优化哪些优先级较低的任务。
  4. 使用 react.lazy()方法去包裹路由，实现路由的懒加载。

- 总结：

  1. 上面的几点都可以，下面是新增加的。
  2. 使用 useContext 钩子，减少 react 中 props 透传。
  3. 使用服务端渲染，在服务端生成 html，减少客户端渲染时间。
  4. 为列表添加唯一的 Key，帮助 react 高效识别和更新节点。
  5. 组件层级扁平化，减少组件的嵌套层级，降低虚拟 DOM Diff 算法复杂度。
  6. 使用 useReducer 管理复杂状态逻辑，合并多次状态更新以减少渲染次。

## useCallback 和 useMemo 的用法及使用场景？

- 公司

  1. 2024/3/01/10:30 货拉拉面试（外派上海，线上）薪资 10K-11k
  2. 2024/3/27/15:10 上海码纹（自研上海，线上），薪资 15k-25k
  3. 2024/5/07/10:00 万格鑫（南京自研，线上，薪资：10k-15k）
  4. 2024/5/09/15:00 固德威（苏州外派，线上，薪资：15k-18k）
  5. 2024/5/15/10:00 中国李宁（上海外派，线下，薪资：10k-14k）
  6. 2024/12/03/13:30 冥晨网络（自研上海，线下）薪资 10K-14k

- 第一次回答：

  1. useCallback 和 useMemo 都是 react 中用于优化的钩子函数。
  2. 在 react 中父组件的更新会触发子组件的重新渲染，常见的如果不需要子组件重新渲染可以使用 react.Memo 方法进行包裹子组件，react.Memo 中传递两个参数，第一个是接受的组件，第二个参数是一个函数，函数中可以接受组件更新前后的 props，每次调用 react.memo 的时候，都会对更新前后的 props 进行浅比较，比较的方式是通过 Object.is()。所以如果传递的是一个简单的数据类型，这个时候使用 react.memo 包裹会去查看 props 有没有变化，如果有变化则更新子组件，没有变化则不更新，如果传递的是一个对象或者数组，即使传递的对象没有变化，但是父组件的更新仍然会更新子组件。这个时候可以使用 useMemo 对当前的对象进行包裹，useMemo 中接收两个参数，第一个是一个回调函数，第二个是一个依赖数组。只有当依赖数组中的项发生变化的时候才会去执行回调函数，这个每次父组件更新，但是传递给子组件的对象如果没有变化这会缓存当前的对象，不会造成子组件的重新渲染。useMemo 的使用有点像 vue 中的 computed，用于缓存数据使用，对于大量复杂的计算逻辑也可以存储在 useMemo 中，这样可以有效的减少不必要的渲染。
  3. useCallback 和 useMemo 的不同是 useMemo 是基于依赖进行缓存的，同时有返回值。useCallback 是用于缓存一个函数，还是上面的场景，如果父组件传递给子组件的是一个函数，那么这个函数传递给子组件中的 react.memo 中进行浅比较会显示 false，则会更新子组件，这个时候就可以使用 useCallback 进行包裹需要缓存的函数。避免生成新的函数实例。

- 总结：上面的基本 OK

## react 中组件传值的方式有哪些？

- 公司：

  1. 2024/4/25/10:00 缔塔科技（自研上海，线下，薪资：11K-16K）
  2. 2024/5/15/10:00 中国李宁（上海外派，线下，薪资：10k-14k）

- 第一次回答：

- 总结：
